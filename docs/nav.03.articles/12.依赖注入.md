---
author: 三棵树
title: 依赖注入
---

## 什么是依赖注入

[Angular 中的依赖注入](https://angular.cn/guide/dependency-injection)

## 关于 declareProviders

首先不得不提到的一点是什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。

首先从名字入手，依赖注入可以分成依赖和注入。

#### 什么是依赖？

比如我定义一个类 CountService，这个类有一个构造函数 constructor，这个构造函数有一个参数 LoggerService 的实例。
`显然这个 LoggerService 实例需要在 CountService 外部实例化`，然后再传递给 CountService 的构造函数。
这时可以说 CountService 的依赖就是 LoggerService。

#### 什么是注入呢？

上面提到的 LoggerService 实例的处理过程就是注入。
准确的说就是依赖注入框架会帮我们实例化一个 LoggerService 实例 loggerService，然后再以该 loggerService 作为参数帮我实例化一个 CountService 实例 countService。也就是屏蔽了我们自己手动实例化的过程。

总体来说是解决了这样一个问题，正常我们应该这么写代码

```ts
const loggerService = new LoggerService();
const countService = new CountService(loggerService);
```

通过依赖注入，我们可以这样来获取 countService

```ts
const countService = useService(CountService);
```

这里再多嘴说一句，从上面的分析来看，useService 这个函数是用来获取实例的，但却不一定是必须的。比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中包括服务和组建都是可注入的。但是在 vue 中组件本身就不能注入了。我们只能做到在组件中注入服务或者在服务中注入服务。并且没有办法在组件的构造函数中声明依赖的其他服务。因为 vue 中的组件就没有构造函数。其实也可以增加一个 decorator 同时借助 vue-class-component 来尝试实现在组件构造函数中声明依赖服务。但是目前来看还是提供一个 useService 函数来获取实例比较直观。

我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。
本质上就是 Key-Value 的魔法。比如：

```ts
defineKeyValue("tokenA", "valueA"); // 内部使用map来记录对应关系
const value = getValueByKey("tokenA"); // 再通过map.get(key)获取数据即可
```

可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。

```ts
defineKeyValue("tokenA", ClassA); // 内部使用map来记录对应关系
const value = getValueByKey("tokenA"); // 再通过map.get(key)获取到ClassA，然后实例化一个实例返回
```

当然如果要处理 ClassA 依赖 ClassB 这种场景，就需要其他方面的支持。比如 typescript 以及 decorator。
因为这属于技术问题，不属于概念问题，这里不再细述。

#### 还剩下一个问题：上面的支持类的实例化的依赖注入能力还有没有其他问题？

其实还有数据的命名空间的问题。显然上面所有的数据都处于同一个命名空间下。大多数场景应该也没有什么问题。但是确实还可以继续提升一下。
本库参考 angular 把数据绑定在组件上，默认是绑定在根组件上，可以理解为公共的全局的命名空间。

如果在业务上认为某个数据和某个组件是绑定的，就需要用到 `declareProviders([CountService])`。

这样意味着 CountService 不一定就是单例的，只要有需要，就可以在不同的组件上声明新的命名空间。
当然在同一个命名空间下，同一个 CountService 对应的实例只有一个。
当然 useService 会从当前最近的命名空间中开始寻找 CountService 的声明，如果没有找到继续从父组件中寻找。
如果一直到根组件也没有找到，则在根组件对应的命名空间下生成一个新的实例。

这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。

## 关于依赖注入和 import/export 的区别

1. import/export 适合单例
2. import/export 强制依赖某个实例/具体的数据
3. 依赖注入解藕了依赖声明和依赖的实例化。比如声明依赖 LoggerService，但是可以通过配置修改为 OtherLoggerService 的实例
4. [Vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？](https://www.zhihu.com/question/391394082/answer/1188254737)
5. [前端什么时候用 import 什么时候用依赖注入?](https://www.zhihu.com/question/374161373/answer/1034772082)

## 图解

通过图片中不同的颜色可以区分出 declareProviders 划分出来不同的命名空间。

![hello logo](/demo.png)

## 什么是 provider

因为本库的依赖注入的思想是来自于 angular，所以大家可以直接查看[angular 的官方文档](https://angular.cn/guide/dependency-injection-providers#using-an-injectiontoken-object)。这里我再说说我的理解。

provider 字面意思就是提供者，这里具体一点就是服务的提供者。服务提供者是用来解决一个问题：服务是怎么来的？

提到服务，我们必须了解两个概念：服务名字和服务来源。最常见的 provider 如下：

```ts
{
  provide: AppleService, // 这是服务名字
  useClass: AppleService, // 这是服务来源
}
```

<Vssue title="Vssue Demo" />
