---
author: kaokei
title: 最佳实践指导
---

## 最佳实践

建议将 declareProviders([...])单独放在一个 container component 中，这样可以保证组件本身是干净的。
或者至少要放在 setup 函数的顶部，因为如果出现在 useService 之后，就会导致获取的实例出现异常。

就算有了服务，也不代表所有数据就一定需要放在服务中。
比如控制弹窗是否显示的变量 isModalShow，一般应该放在组件中即可。
当然也不是 100%这样，如果多个组件都需要控制这个弹窗是否显示，就应该把这个变量放在服务中了

建议自己基于 axios/superagent 封装自己的 HttpClientService
然后基于 HttpClientService 封装自己的 DaoService
我个人建议是一个项目只需要一个 DaoService，并不需要按照模块划分成多个。
我理解一个项目大多数情况下很难超过 200 条接口。维护在一个服务中是可以接受的。
再然后 StudentService，TeacherService，ClassService 这些业务 Service 直接注入 DaoService 即可。

数据的生命周期应该和组件的生命周期一致，当组件销毁时，数据也应该跟着销毁。
子组件的生命周期应该受到父组件的生命周期的约束。当父组件销毁时，子组件也要跟着销毁。
如果子组件的销毁完全只受父组件控制，那么可以把所有数据都放在父组件中即可。
如果子组件也会绑定到子路由，则相应的数据也可以绑定到该子组件。
目前来看，数据默认会绑定到全局。其他情况数据应该绑定到路由组件，以及子路由组件上。

不要通过 props 传递 service

<Vssue title="最佳实践" />

## @skip 为什么没有实现多层跳过，以及如何实现跳过多层获取服务

@Skip 有一个可选的参数。

```ts
// 接口定义
@Skip(skipNum?: number|boolean)
// 以下三种是等价的
@Skip() === @Skip(true) === @Skip(1)
```

要想了解@skip 的作用，就得知道@Inject 的作用。而@Inject 的作用，则是和 useService 是等价的。

useService 会从当前组件的命名空间中寻找服务的 provider，如果没有找到。就从父组件中寻找，如果还没有找到，还继续从父组件的父组件中寻找，一直找到根组件中。如果寻找到对应服务的 provider，那么就使用该 provider 获取服务的实例对象。如果在根组件的命名空间中也没有找到对应的 provider。那么就把服务类当作默认的 provider，再根据这个默认的 provider 获取服务的实例对象。

整个解析过程非常像 js 中的原型链和 nodejs 中的 node_modules 的解析机制。

那么@Skip 的作用就很明确了，@Skip(num)代表向上解析的过程中跳过的次数。注意这里并不是代表跳过的父组件的次数。而是指跳过解析对应服务的次数。

比如这段代码：

```ts
@Skip()
private logger1: LoggerService
```

这里@Skip()代表向上跳过 1 次，这里的一次并不是向上跳过一次父组件，而是指在向上解析的过程中，如果第一次遇到了 LoggerService 的 provider，那么跳过 1 次。第二次解析到 LoggerService 的 provider，才是真正想要的 provider。

注意：@Skip(999)代表向上解析跳过 999 次，显然正常是不会解析这么多层就已经到根组件了，此时就不再向上跳过了，而是默认使用根组件的默认 provider 了。

## @Skip 和@Self 本身的缺陷

因为没有自身 Injector 这个概念。

## @kaokei/di 默认支持了实例属性可以设置默认值

直接使用=赋值即可。

## 依赖注入连接到 angular 的页面

解释 useExisting 和 useClass 的区别。
