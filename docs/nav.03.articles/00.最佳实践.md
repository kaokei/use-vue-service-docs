---
author: kaokei
title: 最佳实践指导
---

## 最佳实践

建议将 declareProviders([...])单独放在一个 container component 中，这样可以保证组件本身是干净的。
或者至少要放在 setup 函数的顶部，因为如果出现在 useService 之后，就会导致获取的实例出现异常。

就算有了服务，也不代表所有数据就一定需要放在服务中。
比如控制弹窗是否显示的变量 isModalShow，一般应该放在组件中即可。
当然也不是 100%这样，如果多个组件都需要控制这个弹窗是否显示，就应该把这个变量放在服务中了

建议自己基于 axios/superagent 封装自己的 HttpClientService
然后基于 HttpClientService 封装自己的 DaoService
我个人建议是一个项目只需要一个 DaoService，并不需要按照模块划分成多个。
我理解一个项目大多数情况下很难超过 200 条接口。维护在一个服务中是可以接受的。
再然后 StudentService，TeacherService，ClassService 这些业务 Service 直接注入 DaoService 即可。

数据的生命周期应该和组件的生命周期一致，当组件销毁时，数据也应该跟着销毁。
子组件的生命周期应该受到父组件的生命周期的约束。当父组件销毁时，子组件也要跟着销毁。
如果子组件的销毁完全只受父组件控制，那么可以把所有数据都放在父组件中即可。
如果子组件也会绑定到子路由，则相应的数据也可以绑定到该子组件。
目前来看，数据默认会绑定到全局。其他情况数据应该绑定到路由组件，以及子路由组件上。

不要通过 props 传递 service

## @skip 为什么没有实现多层跳过，以及如何实现跳过多层获取服务

@Skip 有一个可选的参数。

```ts
// 接口定义
@Skip(skipNum?: number|boolean)
// 以下三种是等价的
@Skip() === @Skip(true) === @Skip(1)
```

要想了解@skip 的作用，就得知道@Inject 的作用。而@Inject 的作用，则是和 useService 是等价的。

useService 会从当前组件的命名空间中寻找服务的 provider，如果没有找到。就从父组件中寻找，如果还没有找到，还继续从父组件的父组件中寻找，一直找到根组件中。如果寻找到对应服务的 provider，那么就使用该 provider 获取服务的实例对象。如果在根组件的命名空间中也没有找到对应的 provider。那么就把服务类当作默认的 provider，再根据这个默认的 provider 获取服务的实例对象。

整个解析过程非常像 js 中的原型链和 nodejs 中的 node_modules 的解析机制。

那么@Skip 的作用就很明确了，@Skip(num)代表向上解析的过程中跳过的次数。注意这里并不是代表跳过的父组件的次数。而是指跳过解析对应服务的次数。

比如这段代码：

```ts
@Skip()
private logger1: LoggerService
```

这里@Skip()代表向上跳过 1 次，这里的一次并不是向上跳过一次父组件，而是指在向上解析的过程中，如果第一次遇到了 LoggerService 的 provider，那么跳过 1 次。第二次解析到 LoggerService 的 provider，才是真正想要的 provider。

注意：@Skip(999)代表向上解析跳过 999 次，显然正常是不会解析这么多层就已经到根组件了，此时就不再向上跳过了，而是默认使用根组件的默认 provider 了。

## @Skip 和@Self 本身的缺陷

因为没有自身 Injector 这个概念。

## @kaokei/di 默认支持了实例属性可以设置默认值

直接使用=赋值即可。

## 依赖注入连接到 angular 的页面

解释 useExisting 和 useClass 的区别。

## 使用 InjectionKey 来声明服务的类型信息

## 根组件和根 Injector 的关系

## 禁止使用 watch

watch 有两个优势。

第一，watch 某个属性，属性变化时更新 10 个属性。如果通过 computed 来实现的话，就需要重复 10 遍代码。

第二，watch 某个属性，属性变化时执行某些副作用，比如请求某个 api、输出日志等。这种功能显然是不能通过 computed 来实现的。

既然如此，为什么还是不建议使用 watch 呢？

因为第一点出现的场景不会特别夸张，就算有 2，3 个属性共同依赖某个属性，那也是建议都写成 computed，而不是把更新逻辑放在 watch 中。

第二点我建议是在触发事件的地方去手动调用更新逻辑，而不是依赖数据驱动副作用。

总结以上两点的本质原因在于，我们可以利用数据驱动模版更新，但是我们不应该利用数据驱动其他副作用。

这涉及到心智模型的问题，我期望的心智模型是数据驱动模版，模版响应事件，在事件中修改数据，数据反过来又驱动模版更新。

这中间最多可以接受 computed 对数据层做一层聚合，但是仍然可以看作是数据层的一部分。

但是如果引入了 watch 就不一样了。因为它破坏了这个简单的心智模型。

第一点、数据变化了不仅仅会驱动模版更新，还会触发 watch 中定义的副作用，谁也不知道这个副作用最终又是怎么影响数据和模版的。

第二点、原本的逻辑是模版响应事件，我们直接在事件中更新数据，数据再反应到模版上。但是引入 watch 之后，我们可能会写出这样的代码：我们在事件中只会更新某个数据，然后在 watch 中观察这个数据，然后执行相应的副作用，最终修改了我们想要的数据，数据驱动模版更新。

很明显我们发现心智模型不一样了，变得更加复杂了。
