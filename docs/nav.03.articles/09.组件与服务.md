---
author: kaokei
title: 组件与服务
---

## 总结 option 组件，类组件和服务的关系

## 为什么使用类来作为服务

类是一种抽象，相对于 hooks 函数更加抽象。

## 类组件是如何收集数据的

当前类组件的依赖注入是在 setup 执行完之后才注入的

这个目前还算不上是缺陷，因为类组件的 setup 函数是 vue-class-component 固定实现的，并不含有业务逻辑。

意味着该 setup 函数中并不会访问类的实例属性。本质是 vue-class-component 提供的 setup 函数本身不能访问`this.$data`。

它只能访问`this.$props $emit $attrs $slots`。

还有，参考缺陷 1，我们知道 setup 不是类组件的合法方法。意味着我们不能像 option 组件一样写 setup 函数。

注意虽然 option 组件中的 setup 函数虽然也是只能访问 props 和 ctx，但是一个组件只有一个 setup 函数，在该 setup 函数内部定义的数据，是可以衍生出新数据的。

但是现在类组件中每个实例属性都对应一个 setup 函数，这些 setup 函数是互相独立的，没有办法做到数据之间的衍生。


## 如何在类组件中使用 setup

首先在 vue 中存在两种组件形式，一种是 Option 组件，即直接声明一个对象，然后配置固定的某些属性即代表一个组件。还有一种形式是类组件。

类组件本事是不被 vue 支持的，需要借助 vue-class-component 才能工作。还好 vue-class-component 也是 vue 官方支持的。

在 Option 组件中，我们可以直接配置 setup 属性。但是在类组件中，我们不能在类中直接写一个 setup 属性/或者 setup 函数。

实际上在类组件的类中只能写特定的属性和方法。比如生命周期函数，其他函数都相当于 Option 组件中的 methods 中定义的方法。

类组件中的属性则相当于 Option 组件中的 data 定义的数据。

我们可以发现，在 Option 组件还有其他的属性或者方法似乎不知道在什么地方定义了。

比如 watch 属性，computed 属性，setup 函数，props 属性，directives 属性，components 属性。

对于 computed 属性应该定义为类的 getter 方法。

对于 setup，则需要`import { setup } from 'vue-class-component'`，然后使用 setup 函数初始化类的属性。

对于 props 属性，则需要`class MyComponent extends Vue.with(SomeProps) {}`，可以[参考这里](https://github.com/vuejs/vue-class-component/issues/465)

其他的属性和函数都需要在`@Options`装饰器中定义。可以[参考这里](https://github.com/vuejs/vue-class-component/issues/406)

顺便提一句，我本以为在类组件中使用 setup，就像在 Option 组件中一样简单，直接在类中定义 setup 方法就可以了。但是实际上这样是行不通的。

如果我们在类组件中定义 setup 方法，那么最终会被 vue-class-component 覆盖掉。实际上 vue-class-component 内部会自动生成一个 setup 函数来收集数据。

所以需要使用 vue-class-component 提供的 setup 函数来延迟初始化类的属性。

根据官方 issue 来看，不能在类中定义 setup 方法的原因是，我们不能根据 setup 方法的返回值类型来修改类的类型。这里的意思是指 setup 的返回值应该设置为类的成员属性，我们可以在运行时做到这一点，但是在类型提示方面做不到。


## 如何在类组件中使用 hooks

在 vue3 中提供了 vca，即`vue composition api`，中文名是组合式 api。一般我们会定义成 useXXX 的形式的函数。类似于 react 中的 hooks。

在 react 中，hooks 函数只能在函数组件中使用或者在别的 hooks 中使用。而在 vue 中，则只能在 setup 函数中使用。那么如果是 Option 组件，则直接在 setup 函数中使用即可。

如果是在类组件中，上面有提到必须借助`import { setup } from 'vue-class-component'`提供的 setup 函数来定义类的属性，那么我们定义的 hooks 也是可以在这个 setup 函数中使用的。

但是这种写法比较丑陋，而且臃肿。使用依赖注入功能完全可以避免这个问题。

还是回到最初的问题，useXXX 是状态和逻辑的封装。如果直接使用，具有强耦合性；可以通过依赖注入服务来降低这种耦合性。


## 如何使用 declareProviders

可以说在 99%的场景中我们都不需要使用 declareProviders，除非业务足够复杂。

当我们不使用 declareProviders 时，意味着所有的服务都是全局的，那么所有的服务的生命周期都是全局的。

如果我们的业务稍微复杂一点，我们可以在页面路由层面使用 declareProviders，这样这些服务的生命周期就是路由级别的，当切换路由的时候，这些服务也会被卸载。

如果我们的业务更加复杂，可以在 2 级路由，3 级路由都这样操作。

上面提到的都是针对路由的操作，之所以首先提到路由，是因为路由的切换，我们可以非常明显的感受到页面的更新，也就是某些组件的卸载和某些组件的创建。这同时也是生命周期的体现。

那么在有生命周期的地方，我们都是可以使用 declareProviders 的。比如复杂的弹窗，tabs 切换。但是实际上我觉得没有必要把服务的生命周期卡的这么死，稍微把服务的生命周期提升一点也是无伤大雅的。

还有一种场景就是某个组件本身需要使用 declareProviders，即我们希望每个组件实例都有自己的服务实例，而不是所有的组件共享服务。比如 Table 组件我们可以提供一个选择了 table 的哪些行的、以及全选/取消全选这种服务。显然我们希望这个服务是每个 table 组件独享的。

<Vssue title="组件与服务" />
